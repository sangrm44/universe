<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Finger-Tracked Particle Physics</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: monospace; }
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; 
        }
        
        /* Small webcam preview */
        #video-container { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 200px; height: 150px; z-index: 2; 
            border: 1px solid #444; border-radius: 8px; 
            overflow: hidden; transform: scaleX(-1); opacity: 0.8;
            /* Hide the video preview until the camera is successfully started */
            display: none; 
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #ui { 
            position: absolute; top: 20px; left: 20px; 
            color: #ccc; z-index: 3; pointer-events: none; 
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            backdrop-filter: blur(4px); border-left: 3px solid #00ff88;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        .stat { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 5px; width: 220px; }
        .val { color: #00ff88; font-weight: bold; }
        .mode-active { color: #ff0055 !important; }

        /* Start Button Styling */
        #start-button {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            padding: 20px 40px;
            font-size: 1.5rem;
            color: #fff;
            background-color: #00ff88;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px #00ff88;
            transition: all 0.3s;
        }
        #start-button:hover {
            background-color: #00e078;
            box-shadow: 0 0 30px #00ff88;
        }
    </style>
</head>
<body>

    <div id="start-button">START CAMERA & FX</div>
    <div id="loader" style="display:none;">BOOTING PHYSICS ENGINE...</div>

    <div id="ui">
        <h1>Flux Hand</h1>
        <div class="stat"><span>Tracking:</span> <span id="track-stat" class="val">Awaiting Start</span></div>
        <div class="stat"><span>Index Finger:</span> <span class="val">Repel (Push)</span></div>
        <div class="stat"><span>Thumb:</span> <span class="val">Attract (Pull)</span></div>
        <div class="stat"><span>Pinch:</span> <span id="pinch-stat" class="val">GRAVITY WELL</span></div>
        <div style="margin-top: 10px; font-size: 0.7rem; color: #888;">Use 1 Hand Only</div>
        <div style="margin-top: 10px; font-size: 0.7rem; color: #888;">Project by ðŸ˜­</div>
    </div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // ... (THREE.js imports remain the same) ...
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration & Initialization (Unchanged) ---
        const PARTICLE_COUNT = 30000;
        const CAM_Z = 15;
        // ... (Physics Params & State Setup Unchanged) ...
        let fingertips = { 
            thumb: { x:0, y:0, z:0, active:false },
            index: { x:0, y:0, z:0, active:false },
            middle: { x:0, y:0, z:0, active:false },
            ring: { x:0, y:0, z:0, active:false },
            pinky: { x:0, y:0, z:0, active:false }
        };
        let isPinching = false;
        let pinchCenter = { x:0, y:0, z:0 };

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.03);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = CAM_Z;
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);
        // ... (Composer/Bloom Pass setup remains the same) ...
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);
        // ... (Particle Geometry/Material/Points setup remains the same) ...
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(PARTICLE_COUNT * 3); 
        const velArray = new Float32Array(PARTICLE_COUNT * 3); 
        const homeArray = new Float32Array(PARTICLE_COUNT * 3); 
        const colorArray = new Float32Array(PARTICLE_COUNT * 3);
        const baseColor = new THREE.Color(0x00ff88); 
        const activeColor = new THREE.Color(0xff0055); 
        // (Particle initialization loop)
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i*3;
            const r = 10 + Math.random() * 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            posArray[i3] = x; posArray[i3+1] = y; posArray[i3+2] = z;
            homeArray[i3] = x; homeArray[i3+1] = y; homeArray[i3+2] = z;
            velArray[i3] = 0; velArray[i3+1] = 0; velArray[i3+2] = 0;
            colorArray[i3] = baseColor.r; colorArray[i3+1] = baseColor.g; colorArray[i3+2] = baseColor.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        const material = new THREE.PointsMaterial({
            size: 0.12,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        const tipGeo = new THREE.BufferGeometry();
        const tipPos = new Float32Array(5 * 3);
        tipGeo.setAttribute('position', new THREE.BufferAttribute(tipPos, 3));
        const tipMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
        const tipPoints = new THREE.Points(tipGeo, tipMat);
        scene.add(tipPoints);
        
        function mapToWorld(x, y, zDepth) {
            const worldX = (x - 0.5) * 25; 
            const worldY = -(y - 0.5) * 20; 
            return { x: worldX, y: worldY, z: zDepth };
        }

        const clock = new THREE.Clock();
        // ... (Animation loop remains the same) ...
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 1. Update visual markers for fingertips
            const tips = tipPoints.geometry.attributes.position.array;
            let tipIdx = 0;
            const fingers = [fingertips.thumb, fingertips.index, fingertips.middle, fingertips.ring, fingertips.pinky];
            
            for(let f of fingers) {
                if(f.active) {
                    tips[tipIdx++] = f.x;
                    tips[tipIdx++] = f.y;
                    tips[tipIdx++] = f.z;
                } else {
                    tips[tipIdx++] = 999; 
                    tips[tipIdx++] = 999;
                    tips[tipIdx++] = 999;
                }
            }
            tipPoints.geometry.attributes.position.needsUpdate = true;

            // 2. Physics Update
            const p = particles.geometry.attributes.position.array;
            const v = velArray;
            const c = particles.geometry.attributes.color.array;
            const home = homeArray;
            
            const pinchStrength = isPinching ? 1.5 : 0;
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;
                let px = p[i3];
                let py = p[i3+1];
                let pz = p[i3+2];

                // A. Base Drift (Noise)
                const noiseX = Math.sin(py * 0.3 + time * 0.5) * 0.01;
                const noiseY = Math.cos(px * 0.3 + time * 0.5) * 0.01;
                v[i3] += noiseX;
                v[i3+1] += noiseY;

                // B. Home Force
                const RETURN_STRENGTH = 0.005;
                v[i3] Â  += (home[i3] - px) * RETURN_STRENGTH;
                v[i3+1] += (home[i3+1] - py) * RETURN_STRENGTH;
                v[i3+2] += (home[i3+2] - pz) * RETURN_STRENGTH;

                // C. Finger Interactions 
                
                // 1. Index Finger: REPULSOR (Wind)
                if (fingertips.index.active) {
                    const dx = px - fingertips.index.x;
                    const dy = py - fingertips.index.y;
                    const dz = pz - fingertips.index.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    if(distSq < 15) { 
                        const dist = Math.sqrt(distSq);
                        const force = (1 - dist / 4) * 0.8; 
                        if(force > 0) {
                            v[i3] += (dx/dist) * force;
                            v[i3+1] += (dy/dist) * force;
                            v[i3+2] += (dz/dist) * force;
                            
                            c[i3] = activeColor.r; c[i3+1] = activeColor.g; c[i3+2] = activeColor.b;
                        }
                    }
                }

                // 2. Thumb: ATTRACTOR (Gravity)
                if (fingertips.thumb.active && !isPinching) {
                    const dx = fingertips.thumb.x - px;
                    const dy = fingertips.thumb.y - py;
                    const dz = fingertips.thumb.z - pz;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    if(distSq < 20) {
                        const dist = Math.sqrt(distSq);
                        const force = 0.05; 
                        v[i3] += (dx/dist) * force;
                        v[i3+1] += (dy/dist) * force;
                        v[i3+2] += (dz/dist) * force;
                    }
                }

                // 3. PINCH: SUPER GRAVITY (Black Hole)
                if (isPinching) {
                    const dx = pinchCenter.x - px;
                    const dy = pinchCenter.y - py;
                    const dz = pinchCenter.z - pz;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    const force = 0.5 / (distSq + 0.1); 
                    v[i3] += dx * force;
                    v[i3+1] += dy * force;
                    v[i3+2] += dz * force;
                    
                    if (distSq < 5) {
                        c[i3] = 1.0; c[i3+1] = 1.0; c[i3+2] = 0.5; 
                    }
                } else {
                    // Color decay back to base
                    c[i3] += (baseColor.r - c[i3]) * 0.05;
                    c[i3+1] += (baseColor.g - c[i3+1]) * 0.05;
                    c[i3+2] += (baseColor.b - c[i3+2]) * 0.05;
                }

                // --- Apply Velocity & Friction ---
                const FRICTION = 0.96;
                v[i3] *= FRICTION;
                v[i3+1] *= FRICTION;
                v[i3+2] *= FRICTION;

                p[i3] += v[i3];
                p[i3+1] += v[i3+1];
                p[i3+2] += v[i3+2];
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            particles.rotation.y = time * 0.02;

            composer.render();
        }

        // --- MediaPipe Logic (Modified to be started by a button) ---
        const videoElement = document.getElementById('input-video');
        const trackStat = document.getElementById('track-stat');
        const pinchStat = document.getElementById('pinch-stat');
        const startButton = document.getElementById('start-button');
        const loader = document.getElementById('loader');
        const videoContainer = document.getElementById('video-container');

        // Initialization of MediaPipe Hands model
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1, 
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        // Function to handle tracking results
        function onResults(results) {
            loader.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                trackStat.innerText = "Locked On";
                trackStat.style.color = "#00ff88";

                const lm = results.multiHandLandmarks[0];
                const Z_DEPTH = 5;

                // Update all 5 fingertips
                const tipLandmarkIndices = [4, 8, 12, 16, 20];
                const tipFingertipKeys = ['thumb', 'index', 'middle', 'ring', 'pinky'];
                
                tipLandmarkIndices.forEach((index, i) => {
                    const key = tipFingertipKeys[i];
                    let p = mapToWorld(lm[index].x, lm[index].y, Z_DEPTH); 
                    fingertips[key].x = p.x; fingertips[key].y = p.y; fingertips[key].z = p.z;
                    fingertips[key].active = true;
                });

                // Detect Pinch
                const dx = fingertips.thumb.x - fingertips.index.x;
                const dy = fingertips.thumb.y - fingertips.index.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 1.5) { 
                    isPinching = true;
                    pinchCenter.x = (fingertips.thumb.x + fingertips.index.x) / 2;
                    pinchCenter.y = (fingertips.thumb.y + fingertips.index.y) / 2;
                    pinchCenter.z = (fingertips.thumb.z + fingertips.index.z) / 2;
                    pinchStat.classList.add('mode-active');
                    pinchStat.innerText = "ACTIVE";
                } else {
                    isPinching = false;
                    pinchStat.classList.remove('mode-active');
                    pinchStat.innerText = "Waiting";
                }

            } else {
                trackStat.innerText = "Searching...";
                trackStat.style.color = "white";
                // Deactivate all fingertips if hand is lost
                Object.values(fingertips).forEach(f => f.active = false);
                isPinching = false;
            }
        }

        // *** IMPORTANT: Wrap camera start logic in a button click ***
        startButton.addEventListener('click', async () => {
            startButton.style.display = 'none';
            loader.style.display = 'block';

            const cam = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            try {
                await cam.start();
                // If successful, show the video container
                videoContainer.style.display = 'block';
                trackStat.innerText = "Loading Model...";
                console.log("Camera started successfully.");
            } catch (err) {
                // Handle permission denial or startup error
                loader.innerText = "ERROR: Camera access denied or failed. Check HTTPS/permissions.";
                loader.style.color = "#ff0055";
                console.error("Failed to start camera. Error:", err);
                trackStat.innerText = "FAILED";
                trackStat.style.color = "#ff0055";
                // Show the start button again, or leave the error message
                startButton.style.display = 'block'; 
                startButton.innerText = "RETRY START";
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>