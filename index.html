<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Finger-Tracked Particle Physics</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* Small webcam preview */
        #video-container { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 200px; height: 150px; z-index: 2; 
            border: 1px solid #444; border-radius: 8px; 
            overflow: hidden; transform: scaleX(-1); opacity: 0.8;
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #ui { 
            position: absolute; top: 20px; left: 20px; 
            color: #ccc; z-index: 3; pointer-events: none; 
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            backdrop-filter: blur(4px); border-left: 3px solid #00ff88;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        .stat { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 5px; width: 220px; }
        .val { color: #00ff88; font-weight: bold; }
        .mode-active { color: #ff0055 !important; }

        #loader { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: #00ff88; font-size: 1.5rem; z-index: 10; 
            text-shadow: 0 0 20px #00ff88;
        }
    </style>
</head>
<body>

    <div id="loader">BOOTING PHYSICS ENGINE...</div>

    <div id="ui">
        <h1>Flux Hand</h1>
        <div class="stat"><span>Tracking:</span> <span id="track-stat" class="val">Searching...</span></div>
        <div class="stat"><span>Index Finger:</span> <span class="val">Repel (Push)</span></div>
        <div class="stat"><span>Thumb:</span> <span class="val">Attract (Pull)</span></div>
        <div class="stat"><span>Pinch:</span> <span id="pinch-stat" class="val">GRAVITY WELL</span></div>
        <div style="margin-top: 10px; font-size: 0.7rem; color: #888;">Use 1 Hand Only</div>
        <div style="margin-top: 10px; font-size: 0.7rem; color: #888;">Project by ðŸ˜­</div>
    </div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const PARTICLE_COUNT = 30000;
        const CAM_Z = 15;
        
        // Physics Params
        const FRICTION = 0.96;
        const RETURN_STRENGTH = 0.005; // Strength to return to original noise field
        const MOUSE_INFLUENCE_RAD = 4.0; 

        // --- State ---
        let fingertips = { 
            thumb: { x:0, y:0, z:0, active:false },
            index: { x:0, y:0, z:0, active:false },
            middle: { x:0, y:0, z:0, active:false },
            ring: { x:0, y:0, z:0, active:false },
            pinky: { x:0, y:0, z:0, active:false }
        };
        let isPinching = false;
        let pinchCenter = { x:0, y:0, z:0 };

        // --- Three.js Init ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Deep space fog
        scene.fog = new THREE.FogExp2(0x020202, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = CAM_Z;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- Post-Processing (Bloom) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Glow effect
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- Particles System ---
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(PARTICLE_COUNT * 3); // Current Pos
        const velArray = new Float32Array(PARTICLE_COUNT * 3); // Velocity
        const homeArray = new Float32Array(PARTICLE_COUNT * 3); // Home (Target) Pos
        const colorArray = new Float32Array(PARTICLE_COUNT * 3);

        const baseColor = new THREE.Color(0x00ff88); // Cyber Green
        const activeColor = new THREE.Color(0xff0055); // Cyber Pink (Interaction)

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i*3;
            // Create a cloud volume
            const r = 10 + Math.random() * 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            posArray[i3] = x;
            posArray[i3+1] = y;
            posArray[i3+2] = z;
            
            homeArray[i3] = x; // Remember where they belong
            homeArray[i3+1] = y;
            homeArray[i3+2] = z;

            velArray[i3] = 0;
            velArray[i3+1] = 0;
            velArray[i3+2] = 0;

            colorArray[i3] = baseColor.r;
            colorArray[i3+1] = baseColor.g;
            colorArray[i3+2] = baseColor.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

        const material = new THREE.PointsMaterial({
            size: 0.12,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Skeleton Visualization (Hand Bones) ---
        // Simple lines to show the user where the computer thinks their hand is
        const lineGeo = new THREE.BufferGeometry();
        const linePos = new Float32Array(21 * 3); // 21 landmarks
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
        const lineMat = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
        const handLines = new THREE.LineSegments(lineGeo, lineMat); 
        // We won't strictly wireframe the skeleton, just dots for debugging is usually enough, 
        // but let's add simple visual markers for fingertips.
        
        const tipGeo = new THREE.BufferGeometry();
        const tipPos = new Float32Array(5 * 3);
        tipGeo.setAttribute('position', new THREE.BufferAttribute(tipPos, 3));
        const tipMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
        const tipPoints = new THREE.Points(tipGeo, tipMat);
        scene.add(tipPoints);


        // --- Interaction Math ---
        // Map 2D normalized coordinates (0..1) to 3D World coordinates at a specific Z depth
        function mapToWorld(x, y, zDepth) {
            // Very rough approximation to align with camera FOV
            const worldX = (x - 0.5) * 25; 
            const worldY = -(y - 0.5) * 20; 
            return { x: worldX, y: worldY, z: zDepth };
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 1. Update visual markers for fingertips
            const tips = tipPoints.geometry.attributes.position.array;
            let tipIdx = 0;
            // Order: Thumb, Index, Middle, Ring, Pinky
            const fingers = [fingertips.thumb, fingertips.index, fingertips.middle, fingertips.ring, fingertips.pinky];
            
            for(let f of fingers) {
                if(f.active) {
                    tips[tipIdx++] = f.x;
                    tips[tipIdx++] = f.y;
                    tips[tipIdx++] = f.z;
                } else {
                    tips[tipIdx++] = 999; // Hide offscreen
                    tips[tipIdx++] = 999;
                    tips[tipIdx++] = 999;
                }
            }
            tipPoints.geometry.attributes.position.needsUpdate = true;

            // 2. Physics Update
            const p = particles.geometry.attributes.position.array;
            const v = velArray;
            const c = particles.geometry.attributes.color.array;
            const home = homeArray;

            // Pre-calculate common variables for optimization
            const pinchStrength = isPinching ? 1.5 : 0;
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;
                let px = p[i3];
                let py = p[i3+1];
                let pz = p[i3+2];

                // --- A. Base Drift (Noise) ---
                // Particles naturally drift slowly like dust
                const noiseX = Math.sin(py * 0.3 + time * 0.5) * 0.01;
                const noiseY = Math.cos(px * 0.3 + time * 0.5) * 0.01;
                v[i3] += noiseX;
                v[i3+1] += noiseY;

                // --- B. Home Force ---
                // Particles want to return to their original shape (Elasticity)
                v[i3]   += (home[i3] - px) * RETURN_STRENGTH;
                v[i3+1] += (home[i3+1] - py) * RETURN_STRENGTH;
                v[i3+2] += (home[i3+2] - pz) * RETURN_STRENGTH;

                // --- C. Finger Interactions ---
                
                // 1. Index Finger: REPULSOR (Wind)
                // Pushes particles away
                if (fingertips.index.active) {
                    const dx = px - fingertips.index.x;
                    const dy = py - fingertips.index.y;
                    const dz = pz - fingertips.index.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    if(distSq < 15) { // Radius of influence
                        const dist = Math.sqrt(distSq);
                        const force = (1 - dist / 4) * 0.8; // Strength
                        if(force > 0) {
                            v[i3] += (dx/dist) * force;
                            v[i3+1] += (dy/dist) * force;
                            v[i3+2] += (dz/dist) * force;
                            
                            // Turn Pink
                            c[i3] = activeColor.r; c[i3+1] = activeColor.g; c[i3+2] = activeColor.b;
                        }
                    }
                }

                // 2. Thumb: ATTRACTOR (Gravity)
                // Pulls particles in gently
                if (fingertips.thumb.active && !isPinching) {
                    const dx = fingertips.thumb.x - px;
                    const dy = fingertips.thumb.y - py;
                    const dz = fingertips.thumb.z - pz;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    if(distSq < 20) {
                        const dist = Math.sqrt(distSq);
                        const force = 0.05; // Gentle pull
                        v[i3] += (dx/dist) * force;
                        v[i3+1] += (dy/dist) * force;
                        v[i3+2] += (dz/dist) * force;
                    }
                }

                // 3. PINCH: SUPER GRAVITY (Black Hole)
                if (isPinching) {
                    const dx = pinchCenter.x - px;
                    const dy = pinchCenter.y - py;
                    const dz = pinchCenter.z - pz;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    // Strong pull everywhere, but stronger near center
                    const force = 0.5 / (distSq + 0.1); 
                    v[i3] += dx * force;
                    v[i3+1] += dy * force;
                    v[i3+2] += dz * force;
                    
                    // Color change to bright white/yellow for energy
                    if (distSq < 5) {
                        c[i3] = 1.0; c[i3+1] = 1.0; c[i3+2] = 0.5; 
                    }
                } else {
                    // Color decay back to base
                    c[i3] += (baseColor.r - c[i3]) * 0.05;
                    c[i3+1] += (baseColor.g - c[i3+1]) * 0.05;
                    c[i3+2] += (baseColor.b - c[i3+2]) * 0.05;
                }

                // --- Apply Velocity & Friction ---
                v[i3] *= FRICTION;
                v[i3+1] *= FRICTION;
                v[i3+2] *= FRICTION;

                p[i3] += v[i3];
                p[i3+1] += v[i3+1];
                p[i3+2] += v[i3+2];
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            // Slowly rotate the whole cloud
            particles.rotation.y = time * 0.02;

            composer.render();
        }

        // --- MediaPipe Logic ---
        const videoElement = document.getElementById('input-video');
        const trackStat = document.getElementById('track-stat');
        const pinchStat = document.getElementById('pinch-stat');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                trackStat.innerText = "Locked On";
                trackStat.style.color = "#00ff88";

                // We only care about the first hand detected
                const lm = results.multiHandLandmarks[0];
                
                // 1. Map Landmarks to 3D World Space
                // Note: We use z-depth = 2 to bring interaction close to camera (particles are at z=0 to z=10 mostly)
                
                // Thumb Tip (4)
                let p = mapToWorld(lm[4].x, lm[4].y, 5); 
                fingertips.thumb.x = p.x; fingertips.thumb.y = p.y; fingertips.thumb.z = p.z;
                fingertips.thumb.active = true;

                // Index Tip (8)
                p = mapToWorld(lm[8].x, lm[8].y, 5);
                fingertips.index.x = p.x; fingertips.index.y = p.y; fingertips.index.z = p.z;
                fingertips.index.active = true;

                // Middle Tip (12)
                p = mapToWorld(lm[12].x, lm[12].y, 5);
                fingertips.middle.x = p.x; fingertips.middle.y = p.y; fingertips.middle.z = p.z;
                fingertips.middle.active = true;

                // Ring (16)
                p = mapToWorld(lm[16].x, lm[16].y, 5);
                fingertips.ring.x = p.x; fingertips.ring.y = p.y; fingertips.ring.z = p.z;
                fingertips.ring.active = true;

                // Pinky (20)
                p = mapToWorld(lm[20].x, lm[20].y, 5);
                fingertips.pinky.x = p.x; fingertips.pinky.y = p.y; fingertips.pinky.z = p.z;
                fingertips.pinky.active = true;

                // 2. Detect Pinch
                const dx = fingertips.thumb.x - fingertips.index.x;
                const dy = fingertips.thumb.y - fingertips.index.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 1.5) { // Threshold for pinch
                    isPinching = true;
                    pinchCenter.x = (fingertips.thumb.x + fingertips.index.x) / 2;
                    pinchCenter.y = (fingertips.thumb.y + fingertips.index.y) / 2;
                    pinchCenter.z = (fingertips.thumb.z + fingertips.index.z) / 2;
                    pinchStat.classList.add('mode-active');
                    pinchStat.innerText = "ACTIVE";
                } else {
                    isPinching = false;
                    pinchStat.classList.remove('mode-active');
                    pinchStat.innerText = "Waiting";
                }

            } else {
                trackStat.innerText = "Searching...";
                trackStat.style.color = "white";
                fingertips.thumb.active = false;
                fingertips.index.active = false;
                isPinching = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1, // STRICTLY 1 HAND
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>